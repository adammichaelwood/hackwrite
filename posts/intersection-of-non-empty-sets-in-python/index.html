<!DOCTYPE html>
<html prefix="            og: http://ogp.me/ns# article: http://ogp.me/ns/article#     " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Intersection of Non-Empty Sets in Python | hack.write()</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="../../assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">
<link rel="canonical" href="http://hackwrite.com/posts/intersection-of-non-empty-sets-in-python/">
<!--[if lt IE 9]><script src="../../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><meta name="author" content="Adam Michael Wood">
<link rel="prev" href="../verbiage/" title="Verbiage" type="text/html">
<link rel="next" href="../registering-functions-against-object-methods-in-python/" title="Registering Functions Against Object Methods in Python" type="text/html">
<meta property="og:site_name" content="hack.write()">
<meta property="og:title" content="Intersection of Non-Empty Sets in Python">
<meta property="og:url" content="http://hackwrite.com/posts/intersection-of-non-empty-sets-in-python/">
<meta property="og:description" content="Suppose you generate several sets on the fly, and you want to find the elements that are in all the sets. That's easy, it's the intersection of sets.
# One syntax option
result = set_one &amp; set_two &amp; s">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2017-04-15T07:48:40-07:00">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="container">
         
    <header id="header"><h1 id="brand"><a href="http://hackwrite.com/" title="hack.write()" rel="home">

        <span id="blog-title">hack.write()</span>
    </a></h1>

        

        
    <nav id="menu"><ul>
<li><a href="../../archive.html">Archive</a></li>
                <li><a href="../../categories/">Tags</a></li>
                <li><a href="../../rss.xml">RSS feed</a></li>
                <li><a href="https://github.com/adammichaelwood/hackwrite">Repo</a></li>
    
    
    </ul></nav></header><main id="content"><article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Intersection of Non-Empty Sets in Python</a></h1>

        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                    Adam Michael Wood
            </span></p>
            <p class="dateline"><a href="." rel="bookmark"><time class="published dt-published" datetime="2017-04-15T07:48:40-07:00" itemprop="datePublished" title="2017-04-15 07:48">2017-04-15 07:48</time></a></p>
                <p class="commentline">
        
    <a href="#disqus_thread" data-disqus-identifier="cache/posts/intersection-of-non-empty-sets-in-python.html">Comments</a>


            
        </p>
<p class="sourceline"><a href="index.md" class="sourcelink">Source</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>Suppose you generate several sets on the fly, and you want to find the elements that are in all the sets. That's easy, it's the intersection of sets.</p>
<pre class="code literal-block"><span></span><span class="c1"># One syntax option</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">set_one</span> <span class="o">&amp;</span> <span class="n">set_two</span> <span class="o">&amp;</span> <span class="n">set_three</span>

<span class="c1"># Another option</span>
<span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">set_one</span><span class="p">,</span> <span class="n">set_two</span><span class="p">,</span> <span class="n">set_three</span><span class="p">)</span>
</pre>


<p>But let's suppose that one or more of your sets is empty. The intersection of any set and an empty set is an empty set. But, that's not what you want. (Well, it wasn't what I wanted, anyway.)</p>
<p>Suppose you want the intersection of all non-empty sets.</p>
<h2>List comprehension</h2>
<p>If the sets are in a list, you can remove the empties. Then unpack the list into the <code>set.intersection()</code> function.</p>
<pre class="code literal-block"><span></span><span class="n">list_of_sets</span> <span class="o">=</span> <span class="p">[</span><span class="n">set_one</span><span class="p">,</span> <span class="n">set_two</span><span class="p">,</span> <span class="n">set_three</span><span class="p">]</span>

<span class="c1"># Empty sets evaluate to false,</span>
<span class="c1"># so will be excluded from list comp.</span>
<span class="n">non_empties</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">list_of_sets</span> <span class="k">if</span> <span class="n">x</span><span class="p">]</span>

<span class="n">solution_set</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">non_empties</span><span class="p">)</span>
</pre>


<p>The asterisk before <code>non_empties</code> unpacks the list into a series of positional arguments. This is needed because <code>set.intersection()</code> takes an arbitrary number of sets, not an iterable full of sets. (It's the same asterisk as in <code>*args</code> in function definitions.)</p>
<p>(Note: You <em>could</em> use a filter instead of a list comprehension, but <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=98196">Guido thinks a list comprehension is better</a>. I agree.)</p>
<h3>With iterable unpacking (tuple unpacking)</h3>
<p>In my case, I was generating the sets in my code, and the solution set always contained only one item. And I wanted the item, not a set with the item. So...</p>
<pre class="code literal-block"><span></span><span class="c1"># initialize an empty list</span>
<span class="n">list_of_sets</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># each time I create a set,</span>
<span class="c1"># append set to list when it is created,</span>
<span class="c1"># instead of naming them individually</span>
<span class="n">list_of_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">thing_that_generates_a_set</span><span class="p">()</span> <span class="p">)</span>

<span class="c1"># drop the empties, find the intersection</span>
<span class="c1"># and unpack the remaining single element</span>
<span class="n">solution</span><span class="p">,</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">list_of_sets</span> <span class="k">if</span> <span class="n">x</span><span class="p">])</span>
</pre>


<p>The comma after <code>solution</code> turns the assignment into a tuple unpacking. If you unpack a collection of one, you get the single item.</p>
<p>By the way, if you end up with more than one item in your collection, and only want the first item, you can do:</p>
<pre class="code literal-block"><span></span>first_item, *_ = some_collection
</pre>


<p>The <code>*</code> indicates a variable number of positional arguments (it's the same asterisk as in <code>*args</code> and in passing the list to <code>set.intersection()</code> above), and the underscore is used as a convention for "not using this stuff."</p>
<pre class="code literal-block"><span></span># you could have done this instead

first_item, *stuff_i_will_not_care_about = some_collection
</pre>


<p>I'll be using that <code>*_</code> below, in the actual code.</p>
<h2>Why would you ever do this?</h2>
<h3>The generalized problem</h3>
<p>From a pool of items, there are three attributes to select for. Specifying any two of them should produce one and only one result.</p>
<h3>More specifically...</h3>
<p>Musical intervals.</p>
<p>A musical interval has:</p>
<ul>
<li>a quality (Major, Minor, Perfect, Augment, or Diminished)</li>
<li>a number (Unison (1), Second (2), Third (3) ... Octave (8))</li>
<li>a distance of half_steps (for example, a major third is 4 half steps)</li>
</ul>
<p>If you know any two of these, you can select the correct one.</p>
<h2>Some actual code</h2>
<pre class="code literal-block"><span></span><span class="k">class</span> <span class="nc">Interval</span><span class="p">():</span>

  <span class="c1">#####################################</span>
  <span class="c1"># ... all sorts of things removed ...</span>
  <span class="c1">#####################################</span>


  <span class="n">instances</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
  <span class="c1"># all instances of Interval</span>


  <span class="nd">@classmethod</span>
  <span class="k">def</span> <span class="nf">get_intervals</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">quality</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">half_steps</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
      <span class="sd">"""Return a set of intervals."""</span>

      <span class="n">candidate_sets</span> <span class="o">=</span> <span class="p">[]</span>

      <span class="n">candidate_sets</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">instances</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">quality</span> <span class="o">==</span> <span class="n">quality</span><span class="p">})</span>

      <span class="n">candidate_sets</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">instances</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="n">number</span><span class="p">})</span>

      <span class="n">candidate_sets</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">instances</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">half_steps</span> <span class="o">==</span> <span class="n">half_steps</span><span class="p">})</span>

      <span class="n">candidate_sets</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">candidate_sets</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

      <span class="k">return</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">candidate_sets</span><span class="p">)</span>

  <span class="nd">@classmethod</span>
  <span class="k">def</span> <span class="nf">get_interval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">quality</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">half_steps</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
      <span class="sd">""" Return a single interval."""</span>

      <span class="k">try</span><span class="p">:</span>
          <span class="n">interval</span><span class="p">,</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">get_intervals</span><span class="p">(</span><span class="n">quality</span><span class="o">=</span><span class="n">quality</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="n">number</span><span class="p">,</span> <span class="n">half_steps</span><span class="o">=</span><span class="n">half_steps</span><span class="p">)</span>

      <span class="c1">## if there was not one and only one result</span>
      <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>

          <span class="c1"># only select by half_steps</span>
          <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">instances</span> <span class="k">if</span> <span class="n">half_steps</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">half_steps</span><span class="p">]</span>

          <span class="c1"># select the first one,</span>
          <span class="c1"># based on quality priority:</span>
          <span class="c1"># Perfect, Major, Minor, Dim, Aug</span>
          <span class="n">interval</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">quality</span><span class="o">.</span><span class="n">priority</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">interval</span>
</pre>


<p>In <a href="https://github.com/OphisMusic/ophis">the actual code</a>, there's a bunch of other things going on, but this is the general idea.</p>
<h2>Another approach</h2>
<p>For my specific use case, another approach is simply to not create a set for the unspecified attribute.</p>
<pre class="code literal-block"><span></span><span class="k">if</span> <span class="n">quality</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">candidate_sets</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">instances</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">quality</span> <span class="o">==</span> <span class="n">quality</span><span class="p">})</span>

<span class="k">if</span> <span class="n">number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">candidate_sets</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">instances</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="n">number</span><span class="p">})</span>

<span class="k">if</span> <span class="n">half_steps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">candidate_sets</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">instances</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">half_steps</span> <span class="o">==</span> <span class="n">half_steps</span><span class="p">})</span>
</pre>


<p>In my working code, I actually do both. This allows for a potentially meaningful result even if something is specified incorrectly. I could have decided to let bad input cause explicit failure, but I <strong>think</strong> I'd rather not in this case.</p>
<h2>So... what's the point?</h2>
<p>This post looks like a tutorial on list comprehension. Or maybe set operations. But really this post is about problem solving while writing code.</p>
<p>The code solution to this problem is really easy... but <em>only if you've figured out the problem you need to solve</em>.</p>
<p>I started with the following problem:</p>
<blockquote>
<p>Find the intersection of all non-empty sets, from an arbitrary pool of sets, not knowing which ones would be empty.</p>
</blockquote>
<p>So I started Googling variations on that theme. But there aren't any "intersection of just the good sets" functions. Then I tried to start writing a question for Stack Overflow, and as soon as I had written the title, I knew the answer.</p>
<blockquote>
<p>Starting with a collection of sets, drop the empty sets and find the intersection of the remaining sets.</p>
</blockquote>
<p>As soon as I broke my one problem into two steps, the problem was immediately solved:</p>
<ol>
<li>Create a new collection without the empties. (List comp.)</li>
<li>Find the intersection of <em>that</em> list.</li>
</ol>
<p>At the same moment I realized these steps, it also become clear that the original group of sets should be a collection, not just several unrelated objects.</p>
<p>So, the moral of the story is...</p>
<p>If you can't find the solution to your specific problem, restate your problem as a series of steps.</p>
    </div>
    <aside class="postpromonav"><nav><ul class="pager hidden-print">
<li class="previous">
                <a href="../verbiage/" rel="prev" title="Verbiage">Previous post</a>
            </li>
            <li class="next">
                <a href="../registering-functions-against-object-methods-in-python/" rel="next" title="Registering Functions Against Object Methods in Python">Next post</a>
            </li>
        </ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
        
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="adammichaelwood",
            disqus_url="http://hackwrite.com/posts/intersection-of-non-empty-sets-in-python/",
        disqus_title="Intersection of Non-Empty Sets in Python",
        disqus_identifier="cache/posts/intersection-of-non-empty-sets-in-python.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        </section></article><script>var disqus_shortname="adammichaelwood";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script></main><footer id="footer"><p>© 2016–2017 <a href="mailto:adam.michael.wood@gmail.com">Adam Michael Wood</a> - <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> <br><span id="powered-by">Powered by <a href="https://getnikola.com" rel="nofollow">Nikola</a></span></p>
            
        </footer>
</div>
    
    

        <script src="../../assets/js/baguetteBox.min.js"></script><script>baguetteBox.run('a.reference', {
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-46189469-6', 'auto'); ga('send', 'pageview');</script>
</body>
</html>
